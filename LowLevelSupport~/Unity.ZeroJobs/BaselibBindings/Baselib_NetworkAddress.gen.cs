//
// File autogenerated from Include/C/Baselib_NetworkAddress.h
//

using System;
using System.Runtime.InteropServices;
using size_t = System.UIntPtr;

namespace Unity.Baselib.LowLevel
{
    internal static unsafe partial class Binding
    {
        /// <summary>
        /// Address family.
        /// </summary>
        public enum Baselib_NetworkAddress_Family : Int32
        {
            Invalid = 0x0,
            IPv4 = 0x1,
            IPv6 = 0x2,
        }
        /// <summary>Fixed size address structure, large enough to hold IPv4 and IPv6 addresses.</summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct Baselib_NetworkAddress
        {
            // byte data[16];
            public byte data0;
            public byte data1;
            public byte data2;
            public byte data3;
            public byte data4;
            public byte data5;
            public byte data6;
            public byte data7;
            public byte data8;
            public byte data9;
            public byte data10;
            public byte data11;
            public byte data12;
            public byte data13;
            public byte data14;
            public byte data15;
            /// <summary>in network byte order</summary>
            // byte port[2];
            public byte port0;
            public byte port1;
            public byte family;
            /// <summary>This struct consists entirely of uint8_t and as such its size would be 19.</summary>
            /// <remarks>
            /// Since we align the port to 2 though, padding is automatically added. However, right now our binding generator does not read this out.
            /// So to be a bit safer we add this manual padding.
            /// </remarks>
            public byte _padding;
        }
        /// <summary>Max length of any string representing an IP address</summary>
        public const UInt32 Baselib_NetworkAddress_IpMaxStringLength = 46;
        /// <summary>
        /// Binary encode string representation of an address.
        /// </summary>
        /// <remarks>
        /// Possible error codes:
        /// - Baselib_ErrorCode_InvalidArgument - One or more of the input parameters are invalid
        /// </remarks>
        [DllImport(BaselibNativeLibrary.DllName, CallingConvention=CallingConvention.Cdecl)]
        public static extern void Baselib_NetworkAddress_Encode(Baselib_NetworkAddress* dstAddress, Baselib_NetworkAddress_Family family, byte* ip, UInt16 port, Baselib_ErrorState* errorState);
        /// <summary>
        /// Decode binary representation of an address.
        /// </summary>
        /// <remarks>
        /// family, ipAddressBuffer, and port are all optional arguments.
        /// passing zero as  ipAddressBufferLen is the same as passing an ipAddressBuffer nullptr.
        /// 
        /// Possible error codes:
        /// - Baselib_ErrorCode_InvalidArgument - srcAddress is null or otherwise invalid.
        /// - Baselib_ErrorCode_InvalidBufferSize - ipAddressBuffer is too small to hold decoded ip address.
        /// </remarks>
        [DllImport(BaselibNativeLibrary.DllName, CallingConvention=CallingConvention.Cdecl)]
        public static extern void Baselib_NetworkAddress_Decode(Baselib_NetworkAddress* srcAddress, Baselib_NetworkAddress_Family* family, byte* ipAddressBuffer, UInt32 ipAddressBufferLen, UInt16* port, Baselib_ErrorState* errorState);
        public enum Baselib_NetworkAddress_AddressReuse : Int32
        {
            DoNotAllow = 0x0,
            /// <summary>Allow multiple sockets to be bound to the same address/port.</summary>
            /// <remarks>All sockets bound to the same address/port need to have this flag set.</remarks>
            Allow = 0x1,
        }
    }
}
